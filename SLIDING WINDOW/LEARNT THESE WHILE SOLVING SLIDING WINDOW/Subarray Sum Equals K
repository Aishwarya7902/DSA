PROBLEM:https://leetcode.com/problems/subarray-sum-equals-k/
VIDEO:https://youtu.be/HbbYPQc-Oo4
/*
BRUTE FORCE:
TC:O(N*3)
SC:O(1)
*/
#include<bits/stdc++.h>
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int count=0;
        int n=nums.size();
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int sum=0;
                for(int k=i;k<=j;k++){
                    sum+=nums[k];
                }
                if(sum==k){
                    count++;
                }
            }
        }
        return count;
    }
};

/* further optimisation
LEARNT A NEW CONCEPT OF PREFIX SUM HERE...HERE PREFIX SUM NAME IS LS
SUM[i,j]=LS[j]-LS[i-1]
//here SUM[i,j] means sum of the subarray starting form pointer i and ending at j
if(i==0)
SUM[i,j]=LS[j];


tc:O(n)+O(n*2)=O(n*2) here we are using two for loops
sc:O(n) we are using extra vector of prefixSum
*/
#include<bits/stdc++.h>
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        
        int count=0;
        int n=nums.size();
        vector<int>prefixSum;
        int sum=nums[0];
        v.push_back(sum);
        for(int i=1;i<nums.size();i++){
            sum+=nums[i];
            v.push_back(sum);
            
        }
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                
               if(i==0){
                    if(v[j]==k)count++;
                }
                else
                {
                    if((v[j]-v[i-1])==k){
                        count++;
                    }
                }
            }
        }
        return count;
    }
};
